# -*- coding: utf-8 -*-
"""competencia_pro.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O_W-FYbDtHECnVca4GqpLfECOb6L0h0b
"""

#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
import numpy as np
import time
from math import sqrt
from sensor_msgs.msg import LaserScan
from nav_msgs.msg import Odometry
from ackermann_msgs.msg import AckermannDriveStamped

class CompetidorBrandsHatch(Node):
    """
    Nodo de control aut√≥nomo para F1Tenth.
    Implementa algoritmo FGM con optimizaciones para carreras.
    """
    def __init__(self):
        super().__init__('competencia_pro')

        # --- PAR√ÅMETROS DE NAVEGACI√ìN ---
        # Ajustes de velocidad para conducci√≥n agresiva
        self.VEL_RECTA = 4.5
        self.VEL_CURVA = 1.5

        # Par√°metros de seguridad espacial
        self.RADIO_OBSTACULO = 0.5   # Tama√±o de la burbuja de seguridad
        self.UMBRAL_HUECO = 1.5      # Distancia m√≠nima para considerar espacio libre

        # Buffer para suavizado de direcci√≥n (Moving Average)
        self.buffer_direccion = [0.0] * 5

        # --- TELEMETR√çA Y ESTADO ---
        self.origen_x = 0.0
        self.origen_y = 0.0
        self.sistema_iniciado = False

        # M√©tricas de carrera
        self.contador_vueltas = 0
        self.tiempo_inicio_vuelta = 0.0
        self.tiempo_actual = 0.0
        self.mejor_tiempo = float('inf')

        # Control de cruce de meta
        self.zona_salida_superada = False
        self.ultimo_log = 0.0

        # --- INTERFAZ DE ROS 2 ---
        self.sub_laser = self.create_subscription(LaserScan, '/scan', self.procesar_laser, 10)
        self.sub_odom = self.create_subscription(Odometry, '/ego_racecar/odom', self.procesar_odometria, 10)
        self.pub_drive = self.create_publisher(AckermannDriveStamped, '/drive', 10)

        self.get_logger().info("üöÄ SISTEMA DE COMPETENCIA INICIADO üöÄ")

    def procesar_odometria(self, datos):
        """
        Gestiona el cronometraje y la l√≥gica de vueltas.
        """
        pos_x = datos.pose.pose.position.x
        pos_y = datos.pose.pose.position.y

        # Configuraci√≥n inicial del punto de partida
        if not self.sistema_iniciado:
            self.origen_x = pos_x
            self.origen_y = pos_y
            self.sistema_iniciado = True
            self.tiempo_inicio_vuelta = time.time()
            return

        # Actualizaci√≥n del cron√≥metro
        self.tiempo_actual = time.time() - self.tiempo_inicio_vuelta

        # C√°lculo de distancia a la meta
        distancia_origen = sqrt((pos_x - self.origen_x)**2 + (pos_y - self.origen_y)**2)

        # L√≥gica de estado: ¬øEstamos lejos o cerca de la meta?
        if not self.zona_salida_superada and distancia_origen > 3.0:
            self.zona_salida_superada = True

        if self.zona_salida_superada and distancia_origen < 1.0:
            # Filtro temporal para evitar falsos positivos (min 5 segundos)
            if self.tiempo_actual > 5.0:
                self.registrar_vuelta()

        # Visualizaci√≥n en consola (HUD)
        if time.time() - self.ultimo_log > 0.1:
            record_str = f"{self.mejor_tiempo:.2f}" if self.mejor_tiempo != float('inf') else "--"
            # Formato visual distinto
            print(f"\r[CARRERA] Vuelta: {self.contador_vueltas}/10  >>  Tiempo: {self.tiempo_actual:.2f}s  >>  R√©cord: {record_str}s    ", end="")
            self.ultimo_log = time.time()

    def registrar_vuelta(self):
        """L√≥gica al completar una vuelta v√°lida."""
        self.contador_vueltas += 1
        tiempo_final = self.tiempo_actual

        if tiempo_final < self.mejor_tiempo:
            self.mejor_tiempo = tiempo_final

        print(f"\n‚úÖ VUELTA {self.contador_vueltas} COMPLETADA EN {tiempo_final:.2f}s\n")

        # Reinicio de variables para la siguiente vuelta
        self.tiempo_inicio_vuelta = time.time()
        self.tiempo_actual = 0.0
        self.zona_salida_superada = False

    def limpiar_datos_lidar(self, lecturas):
        """Normaliza los datos del sensor usando operaciones vectoriales."""
        datos = np.array(lecturas)
        # Saneamiento de datos: NaN e Infinitos se convierten en 10.0m
        datos = np.nan_to_num(datos, nan=0.0, posinf=10.0)
        datos[datos > 10.0] = 10.0
        return datos

    def procesar_laser(self, msg):
        """
        Algoritmo principal de navegaci√≥n reactiva.
        """
        lecturas = self.limpiar_datos_lidar(msg.ranges)
        total_puntos = len(lecturas)

        # 1. SELECCI√ìN DE CAMPO DE VISI√ìN (FOV)
        # Recortamos para ver solo el sector frontal relevante
        centro = total_puntos // 2
        ancho_vision = total_puntos // 3

        idx_derecha = max(0, centro - ancho_vision)
        idx_izquierda = min(total_puntos, centro + ancho_vision)

        vista_frontal = np.zeros_like(lecturas)
        vista_frontal[idx_derecha:idx_izquierda] = lecturas[idx_derecha:idx_izquierda]

        # 2. SEGURIDAD: APLICACI√ìN DE BURBUJA
        mascara_obstaculos = np.ma.masked_equal(vista_frontal, 0.0)

        if mascara_obstaculos.count() == 0:
            self.enviar_motor(0.0, 0.0) # Freno de emergencia si no hay datos
            return

        dist_minima = mascara_obstaculos.min()
        idx_obstaculo = np.argmin(mascara_obstaculos)

        if dist_minima < 0.3:
            self.enviar_motor(0.0, 0.0) # Parada cr√≠tica
            return

        # Inflado de obst√°culos
        dist_segura = max(dist_minima, 0.01)
        radio_indices = int(self.RADIO_OBSTACULO / (dist_segura * msg.angle_increment))

        burbuja_min = max(0, idx_obstaculo - radio_indices)
        burbuja_max = min(total_puntos, idx_obstaculo + radio_indices)
        vista_frontal[burbuja_min:burbuja_max] = 0.0

        # 3. NAVEGACI√ìN: B√öSQUEDA DE ESPACIO LIBRE
        es_hueco = vista_frontal > self.UMBRAL_HUECO

        # Detecci√≥n de bordes de los huecos
        cambios = np.diff(es_hueco.astype(int))
        inicios = np.where(cambios == 1)[0] + 1
        finales = np.where(cambios == -1)[0] + 1

        if es_hueco[0]: inicios = np.insert(inicios, 0, 0)
        if es_hueco[-1]: finales = np.append(finales, total_puntos)

        if len(inicios) == 0:
            self.enviar_motor(1.0, 0.0) # Avance lento si no hay hueco claro
            return

        # Selecci√≥n del hueco m√°s grande
        anchuras = finales - inicios
        mejor_hueco = np.argmax(anchuras)

        inicio_hueco = inicios[mejor_hueco]
        fin_hueco = finales[mejor_hueco]

        # 4. PUNTO OBJETIVO (GOAL)
        # Estrategia: Ir hacia el punto m√°s profundo del hueco seleccionado
        segmento_hueco = vista_frontal[inicio_hueco:fin_hueco]
        idx_local_max = np.argmax(segmento_hueco)
        idx_objetivo = inicio_hueco + idx_local_max

        # 5. C√ÅLCULO DE DIRECCI√ìN Y VELOCIDAD
        angulo_objetivo = (idx_objetivo - centro) * msg.angle_increment

        # Suavizado de se√±al de control
        self.buffer_direccion.append(angulo_objetivo)
        self.buffer_direccion.pop(0)
        angulo_suave = sum(self.buffer_direccion) / len(self.buffer_direccion)

        # Control de velocidad basado en curvatura
        velocidad = self.VEL_RECTA if abs(angulo_suave) < 0.15 else self.VEL_CURVA

        # Ajuste intermedio para curvas suaves
        if 0.15 <= abs(angulo_suave) < 0.3:
            velocidad = 3.0

        self.enviar_motor(velocidad, angulo_suave)

    def enviar_motor(self, vel, angulo):
        """Publica el comando Ackermann."""
        msg = AckermannDriveStamped()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = "ego_racecar"

        msg.drive.speed = float(vel)
        # Restricci√≥n f√≠sica del giro (-0.4 a 0.4 rads)
        msg.drive.steering_angle = float(np.clip(angulo, -0.4, 0.4))

        self.pub_drive.publish(msg)

def main(args=None):
    rclpy.init(args=args)
    nodo = CompetidorBrandsHatch()
    try:
        rclpy.spin(nodo)
    except KeyboardInterrupt:
        pass
    nodo.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()